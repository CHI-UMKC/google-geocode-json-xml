---
title: 'Google Geocoding: XML Example'
output: html_document
---

### Earl F Glynn, UMKC Center for Health Insights 

These notes show an XML Google Geocoding example using R.  See [Google info about geocoding with XML output](https://developers.google.com/maps/documentation/geocoding/).

Let's use the [XML package](http://cran.r-project.org/web/packages/XML/index.html).

# get.geocode R function

A *get.geocode* function was written to hide most of the XML details.

Google says ["All Geocoding API applications should use an API key"](https://developers.google.com/maps/documentation/geocoding/#api_key), but they appear to allow a small number of API calls without a key, like the one shown below.

Google's example shows the various parts of the address are separated by a comma and a space, which is converted to a "+".  We'll follow their example in forming the URL below.

```{r}
# Google Geocoding:  XML Example
# Earl F Glynn, Franklin Center for Government & Public Integrity, 2010-12-15.

library(XML)     # htmlTreeParse

# Function to call Google's Geocoding API for given street, city and state.
# "id" could be used to add a "key" to the data record being processed.
get.geocode <- function (id, street, city, state, zip)
{
  address <- paste(street, city, state, zip, sep=", ")
  URL <- paste("http://maps.googleapis.com/maps/api/geocode/xml?address=",
               gsub(" ", "+", address), "&sensor=false", sep="")
  xml <- htmlTreeParse(URL, useInternal=TRUE)

  status <- unlist(xpathApply(xml, "//status", xmlValue))

  # if more than one, pick only the first in result[1]
  if (status == "OK")
  {
    results <- getNodeSet(xml, "//result")
    result.count <- length(results)     # study why this is ever > 1

    formatted.address <- unlist(xpathApply(xml, "//result[1]/formatted_address", xmlValue))    
    if (is.null(formatted.address)) formatted.address <- ""
    
    # Add "geo" prefix.  Can later compare if input and output zips match.
    geozip5 <- unlist(xpathApply(xml, "//result[1]/address_component[* = 'postal_code']/long_name", xmlValue))
    if (is.null(geozip5)) geozip5 <- ""
    
    geozip4 <- unlist(xpathApply(xml, "//result[1]/address_component[* = 'postal_code_suffix']/long_name", xmlValue))
    if (is.null(geozip4)) geozip4 <- ""

    # use "state.code" since "state.name" is a defined R dataset
    state.code        <- unlist(xpathApply(xml, "//result[1]/address_component[* = 'administrative_area_level_1']/long_name", xmlValue))
    if (is.null(state.code)) state.code <- ""

    county <- unlist(xpathApply(xml, "//result[1]/address_component[* = 'administrative_area_level_2']/long_name", xmlValue))
    if (is.null(county)) county <- ""

    establishment <- unlist(xpathApply(xml, "//result[1]/address_component[* = 'establishment']/long_name", xmlValue))
    if (is.null(establishment)) establishment <- ""

    lat <- unlist(xpathApply(xml, "//result[1]/geometry/location/lat", xmlValue))
    if (is.null(lat)) lat <- ""
    lng <- unlist(xpathApply(xml, "//result[1]/geometry/location/lng", xmlValue))
    if (is.null(lng)) lng <- ""

    location.type <- unlist(xpathApply(xml, "//result[1]/geometry/location_type", xmlValue))
    if (is.null(location.type)) location.type <- ""
  } else {
    formatted.address <- ""
    geozip5 <- ""
    geozip4 <- ""
    state.code <- ""
    county <- ""
    lat <- ""
    lng <- ""
    location.type <- ""
    establishment <- ""
    result.count <- 0
  }

  free(xml)

  data.frame(id, status, street, city, state, state.code, zip, geozip5, geozip4, county,
             lat, lng, location.type,
             formatted.address, establishment, result.count,
             stringsAsFactors=FALSE)
}
```

## Example use of get.geocode function

Let's use the address of the UMKC School of Medicine:

```{r}
id     <- "UMKC SOM"
street <- "2411 Holmes St"
city   <- "Kansas City"
state  <- "MO"
zip    <- "64108"

d <- get.geocode(id, street, city, state, zip)    
```

## Data.frame of geocoded results
```{r}
d
```

This example will be updated to reflect problems and workarounds found while using Google's geocoding API.

*efg*  
`r format(Sys.time(), "%Y-%m-%d %H%M")`
                                                                                   